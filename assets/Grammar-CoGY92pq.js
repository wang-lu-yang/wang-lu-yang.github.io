import{_ as p}from"./指令-OR9VwLml.js";import{C as o}from"./CodeBlock-BeUO-N7C.js";import{C as r}from"./CodeLine-BM18u3Y-.js";import{C as a}from"./Cite-BIYFNzwB.js";import{a as d,o as u,c as g,h as s,A as e,g as n,B as v,F as C}from"./index-M27ktbsT.js";import"./Index-aTzL6mIO.js";const V="/assets/%E5%85%83%E7%B4%A0-CwWcpozU.png",q=d({__name:"Grammar",emits:["updateOutlineList"],setup(b,{emit:l}){const i=m=>`{{ ${m} }}`;return l("updateOutlineList",[{id:"#grammar_doctype",title:"文档类型（DOCTYPE）"},{id:"#grammar_comment",title:"注释（Comment）"},{id:"#grammar_element",title:"元素（Element）"},{id:"#grammar_tag",title:"标签（Tag）"},{id:"#grammar_attribute",title:"属性（Attribute）"},{id:"#grammar_content",title:"内容（Content）"}]),(m,t)=>(u(),g(C,null,[t[22]||(t[22]=s("p",null," 从本质上来讲Vue中的模板语言并非严格意义上的html语言，因为Vue中额外定义了模板插值、属性绑定、v-指令、插槽、动态组件等语法，此外Vue也并非支持html语言的所有特性，比如html中的条件注释，有的会被Vue当作普通注释处理，有的则会被忽略。因此在介绍模板解析函数之前，需要先了解清楚我们可以在模板内写入什么内容。 ",-1)),t[23]||(t[23]=s("h5",{id:"grammar_doctype"},"· 文档类型（DOCTYPE） ",-1)),s("p",null,[t[0]||(t[0]=e(" 文档类型仅仅应当出现在所有文档的头部，用于表示文档类型，比如html类型的文档可以写成 ")),n(r,{code:"<!DOCTYPE html>"}),t[1]||(t[1]=e(" 。对于Vue工程而言，文档类型应当写在")),t[2]||(t[2]=s("b",null,"index.html",-1)),t[3]||(t[3]=e("文件内，而非模板语法内。因此写在模板内的DOCTYPE虽然也可以被源码正常识别，但是却不会进行任何操作，而是直接被忽略。 "))]),n(o,{lang:"ts",path:"/src/compiler/parser/html-parser.ts",lines:[27,"...",111,112,113,114,115,116],code:`const doctype = /^<!DOCTYPE [^>]+>/i

// Doctype:
const doctypeMatch = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}
`}),t[24]||(t[24]=s("h5",{id:"grammar_comment"},"· 注释（Comment） ",-1)),s("p",null,[t[4]||(t[4]=e(" Vue模板中的注释与html内相同，格式都是以 ")),n(r,{code:"<!--"}),t[5]||(t[5]=e(" 开头，以 ")),n(r,{code:"-->"}),t[6]||(t[6]=e("结尾，中间可以是任意内容，可以是单行也可以是多行。 "))]),s("p",null,[t[7]||(t[7]=e(" 此外还有一种条件注释，主要用于在IE浏览器中根据特定条件来包含或排除html代码。这种代码在现代浏览器中已经不再被支持，在Vue代码中我们虽然可以正常插入条件注释而不导致报错，但是代码却并不会按条件注释的方式来执行。如下所示，条件注释一共有两种格式，第一种格式是以 ")),n(r,{code:"<!["}),t[8]||(t[8]=e(" 开头，以 ")),n(r,{code:"]>"}),t[9]||(t[9]=e("结尾，Vueh会将条件注释内的if和endif去除，而将content仍会被保留。第二种格式是在第一种格式的基础上兼容普通注释的格式形成的，Vue并不会加以区别，而是直接将其当作普通注释处理。 "))]),n(o,{lang:"html",code:`<![if expression]>content<![endif]>
<!--[if expression]>content<![endif]-->
`}),t[25]||(t[25]=v('<h5 id="grammar_element">· 元素（Element） </h5><p> 元素是组成模板语言的基础要素，其格式如下图所示。这里分为普通标签和自闭合标签两种，区别在于，普通标签可以用 <b>&quot;开始标签+内容+结束标签&quot;</b> 的完整内容来写，也可以只保留开始标签并在开始标签的结束符号 <b>&quot;&gt;&quot;</b> 之前加上反斜杠以示结束（这种简写的方式在vue中配合<b>v-html、v-test</b> 指令会非常有用）；自闭合标签则不能有内容或结束标签，而且结束符号之前有没有反斜杠都不影响。也就是说普通标签的简写方式与图中自闭合标签的格式是一样的，为了加以区分Vue源码中有一个专门的函数 <b>isUnaryTag</b> 来判断元素是否为自闭合标签。 </p><img alt="vue element" src="'+V+'"><h5 id="grammar_tag">· 标签（Tag） </h5><p> html的标签都是以英文字母组成的，然而Vue模板中除了html标签之外，还可以含有自定义组件。Vue中对组件名称的要求相对宽松一些，即组件名需要以字母或下划线开头，由字母、数字、下划线、连字符、小数点、甚至unicode字符构成。此外我们还需要考虑到标签名还可以包含命名空间，比如下面这段代码中先定义了svgns命名空间，然后告诉浏览器circle标签是属于svgns命名空间的元素。 </p>',5)),n(o,{lang:"html",code:`<svg
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:svgns="http://www.w3.org/2000/svg"
>
  <svgns:circle cx="150" cy="100" r="50" fill="#ff0000" />
</svg>
`}),s("p",null,[t[10]||(t[10]=e(" 结合以上规则，Vue源码中匹配标签名的正则表达式如下，其中ncname直接用于匹配标签或命名空间的名称，qnameCapture则是结合了两者用于匹配所有元素中可能出现的名称。此外对于开始标签或结束标签而言，开始符号（<, </）之后必须紧跟标签名，而结束符号（>, />）之前则可以有若干空白字符（\\t, \\s, \\v, \\r, \\n）。因此可知源码内startTagOpen、startTagClose、endTag分别用于匹配开始标签开头、开始标签结尾，以及结束标签。只是endTag正则表达式内用 ")),n(r,{code:"/[^>]*/"}),t[11]||(t[11]=e(" 匹配空白字符似乎匹配范围过大。 "))]),n(o,{lang:"ts",path:"/src/compiler/parser/html-parser.ts",start:22,code:"const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${unicodeRegExp.source}]*`\nconst qnameCapture = `((?:${ncname}\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\nconst startTagClose = /^s*(/?)>/\nconst endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`)\n"}),t[26]||(t[26]=s("h5",{id:"grammar_attribute"},"· 属性（Attribute） ",-1)),s("p",null,[t[12]||(t[12]=e(" 属性一般由属性名和属性值组成。其中属性名内不能含有空格、双引号、单引号、尖括号、斜杠、等号，也就是说正则表达式可以写成这样 ")),n(r,{code:`/[^\\s"'<>\\/=]+/`}),t[13]||(t[13]=e(" 。属性值既可以用双引号包括（正则表达式可以写成 ")),n(r,{code:'/"([^"]*)"/'}),t[14]||(t[14]=e(" ）；也可以用单引号包括（正则表达式可以写成 ")),n(r,{code:"/'([^']*)'/"}),t[15]||(t[15]=e(" ）；甚至可以不用任何引号包括，这种方式要求标签值内不能含有空格、双引号、单引号、等号、尖括号、反引号（正则表达式可以写成 ")),n(r,{code:"/[^\\s\"'=<>`]+/"}),t[16]||(t[16]=e(" ）。特别的是如果元素只关心是否有这个属性，而不关心属性值是什么（比如input元素的disabled属性），那么就可以只保留属性名。此外属性之前和等号左右都可以包含若干个空白字符。实际上Vue源码中匹配属性的正则表达式就是结合以上规则写成的（Vue中使用单引号或双引号包括属性值时，也可以由多个连续且相同的引号结束，但这样做并没有什么意义，效果和单个引号结束是一样的）。 "))]),s("p",null,[t[17]||(t[17]=e(" 此外Vue中还支持动态属性，也就是在v-指令之后使用方括号来动态的指定属性名（即下图v-指令语法中的参数部分）。此时匹配指令名称时需要考虑到简写的情况，比如@符号等同于v-on，:等同于v-bind，#等同于v-slot，因此正则表达式可以写成 ")),n(r,{code:"/v-[\\w-]+:|@|:|#/"}),t[18]||(t[18]=e(" 。匹配参数时需要匹配一个中括号，里面是任意变量或JS表达式，Vue中为了防止匹配到赋值语句，加了一个不能匹配等号的限制，因此正则表达式是这样的 ")),n(r,{code:"\\[[^=]+?\\]"}),t[19]||(t[19]=e(" 。匹配修饰符与匹配参数名的情况一致，只不过修饰符是可以省略的。总而言之匹配这种动态属性的规则看上去就像是在普通属性的规则上加了匹配v-指令和动态参数的前缀。 "))]),t[27]||(t[27]=s("img",{alt:"vue directives",src:p},null,-1)),t[28]||(t[28]=s("p",null," Vue源码中匹配普通属性和动态属性的正则表达式如下。注意v-指令中如果没有动态参数，也可以直接被匹配普通属性的正则表达式匹配到。 ",-1)),n(o,{lang:"ts",path:"/src/compiler/parser/html-parser.ts",start:18,code:`const attribute =
  /^s*([^s"'<>/=]+)(?:s*(=)s*(?:"([^"]*)"+|'([^']*)'+|([^s"'=<>\`]+)))?/
const dynamicArgAttribute =
  /^s*((?:v-[w-]+:|@|:|#)[[^=]+?][^s"'<>/=]*)(?:s*(=)s*(?:"([^"]*)"+|'([^']*)'+|([^s"'=<>\`]+)))?/
`}),t[29]||(t[29]=s("h5",{id:"grammar_content"},"· 内容（Content） ",-1)),s("p",null,[t[20]||(t[20]=e(" 模板内容既可以是元素，可以是字符，也可以是插值语法（比如： ")),n(r,{code:i("variable")},null,8,["code"]),t[21]||(t[21]=e(" ）。这里插值语法是在生成html语法树的时候才会被解析，因此html解析代码内会将其当作普通文本传递给上层调用函数处理，并没有提取插值语法的正则表达式， "))]),n(a,{list:["https://html.spec.whatwg.org/multipage/syntax.html#syntax-start-tag","https://developer.mozilla.org/zh-CN/docs/Web/SVG/Namespaces_Crash_Course"]})],64))}});export{q as default};
